<!DOCTYPE html>
<!-- 
 作者:KeJyun
 建立日期:2013-06-09
 最後修改日期:2013-06-09
 聯絡方式:kejyun@gmail.com
 -->
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Laravel 4 PHP Framework Documentation 繁體中文教學文件</title>
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<meta name="description" content="Laravel, 優雅的PHP網頁工匠框架(Framework) 開始享受開發上的樂趣吧!">
<meta name="keyword" content="Laravel,Documentation,教學,文件,繁體,中文,PHP,Framework,框架,優雅" />

<link media="all" type="text/css" rel="stylesheet" href="../../css/style.css">
<script src="../../js/modernizr-2.6.2.min.js"></script>

<style type="text/css">
.docs-menu ul li{
    margin-top: 10px;
}
</style>
</head>
<body>
<!-- Header -->
<header>
    <div class="container">
        <a href="http://laravel.com/" title="Laravel PHP Framework" class="logo" target="_blank">&nbsp;</a>
        <nav class="menu">
            <ul>
                <li>
                    <a href="http://laravel.com/" title="Welcome" target="_blank">Welcome</a>
                </li>
                <li>
                    <a href="http://laravel.com/docs" title="Documentation" target="_blank">Documentation</a>
                </li>
                <li class="active">
                    <a href="../../docs/introduction" title="中文文件">中文文件</a>
                </li>
                <li>
                    <a href="http://laravel.com/api" title="API" target="_blank">API</a>
                </li>
                <li>
                    <a href="https://github.com/laravel/laravel" title="Github" target="_blank">Github</a>
                </li>
                <li>
                    <a href="http://forums.laravel.io/" title="論壇" target="_blank">論壇</a>
                </li>
                <li>
                    <a href="http://twitter.com/laravelphp" title="Twitter" target="_blank">Twitter</a>
                </li>
            </ul>
        </nav>
    </div>
</header>

<!-- Header sectoin -->
<section class="docs-heading">
    <div class="container">
        <h2>文件</h2>
        <div class="sponsor">
            <span>贊助商 </span>
            <a href="http://www.cartalyst.com/" title="Cartalyst" target="_blank">
                <img src="../../img/cartalyst_small.png">
            </a>
        </div>
    </div>
</section>

<section class="docs-content">
    <div class="container">
    <nav class="docs-menu">
        <ul>
            <li>前言                <ul>
                    <li><a href="../../docs/introduction">介紹</a></li>
                    <li><a href="../../docs/quick">快速開始</a></li>
                    <li><a href="../../docs/contributing">貢獻</a></li>
                </ul>
            </li>
            <li>
                入門                <ul>
                    <li><a href="../../docs/installation">安裝</a></li>
                    <li><a href="../../docs/configuration">設定</a></li>
                    <li><a href="../../docs/lifecycle">生命週期</a></li>
                    <li><a href="../../docs/routing">路由</a></li>
                    <li><a href="../../docs/requests">請求及輸入<br />(Requests &amp; Input)</a></li>
                    <li><a href="../../docs/responses">視圖及回應<br />(Views &amp; Responses)</a></li>
                    <li><a href="../../docs/controllers">控制器(Controllers)</a></li>
                    <li><a href="../../docs/errors">錯誤及記錄</a></li>
                </ul>
            </li>

            <li>
                更多                <ul>
                <li><a href="../../docs/cache">快取</a></li>
                <li><a href="../../docs/events">事件</a></li>
                <li><a href="../../docs/facades">Facades</a></li>
                <li><a href="../../docs/html">表單及HTML</a></li>
                <li><a href="../../docs/helpers">Helpers 函式</a></li>
                <li><a href="../../docs/ioc">IoC容器</a></li>
                <li><a href="../../docs/localization">在地化</a></li>
                <li><a href="../../docs/mail">郵件</a></li>
                <li><a href="../../docs/packages">套件開發</a></li>
                <li><a href="../../docs/pagination">分頁</a></li>
                <li><a href="../../docs/queues">佇列</a></li>
                <li><a href="../../docs/security">安全性</a></li>
                <li><a href="../../docs/session">Session</a></li>
                <li><a href="../../docs/templates">樣板</a></li>
                <li><a href="../../docs/testing">單元測試</a></li>
                <li><a href="../../docs/validation">驗證</a></li>
                </ul>
            </li>
            <li>
                資料庫                <ul>
                    <li><a href="../../docs/database">基本用法</a></li>
                    <li><a href="../../docs/queries">Query產生器</a></li>
                    <li><a href="../../docs/eloquent">Eloquent ORM</a></li>
                    <li><a href="../../docs/schema">Schema產生器</a></li>
                    <li><a href="../../docs/migrations">Migrations &amp; Seeding</a></li>
                    <li><a href="../../docs/redis">Redis</a></li>
                </ul>
            </li>

            <li>
                Artisan介面指令                <ul>
                    <li><a href="../../docs/artisan">概要</a></li>
                    <li><a href="../../docs/commands">開發</a></li>
                </ul>
            </li>
        </ul>
    </nav>


    <article class="docs-body">
        <h1>Eloquent ORM</h1>

<ul>
    <li>
        <a href="#introduction">介紹</a>
    </li>
    <li>
        <a href="#basic-usage">基本使用</a>
    </li>
    <li>
        <a href="#mass-assignment">大量指定</a>
    </li>
    <li>
        <a href="#insert-update-delete">新增、更新及刪除</a>
    </li>
    <li>
        <a href="#soft-deleting">微刪除</a>
    </li>
    <li>
        <a href="#timestamps">時間戳記</a>
    </li>
    <li>
        <a href="#query-scopes">查詢範圍</a>
    </li>
    <li>
        <a href="#relationships">關聯</a>
    </li>
    <li>
        <a href="#querying-relations">查詢關聯</a>
    </li>
    <li>
        <a href="#eager-loading">預先加載</a>
    </li>
    <li>
        <a href="#inserting-related-models">新增相關模組</a>
    </li>
    <li>
        <a href="#touching-parent-timestamps">碰觸母節點時間戳記</a>
    </li>
    <li>
        <a href="#working-with-pivot-tables">使用數據透視表</a>
    </li>
    <li>
        <a href="#collections">聚集</a>
    </li>
    <li>
        <a href="#accessors-and-mutators">存取及修改器</a>
    </li>
    <li>
        <a href="#date-mutators">日期設置器</a>
    </li>
    <li>
        <a href="#model-events">模組事件</a>
    </li>
    <li>
        <a href="#model-observers">模組觀察</a>
    </li>
    <li>
        <a href="#converting-to-arrays-or-json">轉換成陣列/JSON</a>
    </li>
</ul>

<p><a name="introduction"></a></p>

<h2>介紹</h2>

<p>
    Eloquent ORM 是 Laravel 提供的一個優雅、簡單的 ActiveRecord 實作資料庫的操作的方法，每個資料表有一個相對應的 "模組 (Model)" ，讓你可以對相對應的資料表進行互動操作。
</p>

<p>
    在開始之前，要先確定你有在 <code>app/config/database.php</code> 檔案中設定好資料庫的連線資訊。
</p>

<p><a name="basic-usage"></a></p>

<h2>基本使用</h2>

<p>
    在開始要建立 Eloquent 模組時，通常這些模組的檔案都放在 <code>app/models</code> 目錄下，但你也可以放在任何你想放的地方，只要能夠透過 <code>composer.json</code> 檔案中的設定去載入模組即可。
</p>

<p><strong>定義 Eloquent 模組</strong></p>

<pre><code>class User extends Eloquent {}
</code></pre>

<p>
    你會注意到，我們並沒有告訴 Eloquent 我們的 <code>User</code> 模組是要用哪一個資料表去做存取控制，除非你有另外指定要使用的資料表名稱，否則 Eloquent 將會使用類別名稱的"小寫"及"複數"的單字去當作預設的資料表名稱，所以在這個例子中， Eloquent 會假設 <code>User</code> 模組的資料是存放在 <code>users</code> 資料表中，你也可以在你的模組中使用 <code>table</code> 變數去指定你想要的使用的資料表名稱:
</p>

<pre><code>class User extends Eloquent {

    protected $table = 'my_users';

}
</code></pre>

<blockquote>
  <p><strong>注意:</strong> Eloquent 會假設每一個資料表的主鍵 (primary key) 名稱為 <code>id</code> ，你也可以使用 <code>primaryKey</code> 變數去複寫原來的規則，同樣的，你也可以定義 <code>connection</code> 變數去複寫你想要在這個模組中使用的資料庫連線。</p>
</blockquote>

<p>
    只要模組一定義完成，你就可以開始取得或建立資料到你的資料表了，但這裡必須注意到，預設的情況下，你必須在資料表中建立 <code>updated_at</code> 及 <code>created_at</code> 這兩個欄位，用來記錄資料的建立時間及更新時間，如果你不希望模組去幫你自動維護資料建立時間及更新時間，在你的模組中你只要將 <code>$timestamps</code> 變數設定為 <code>false</code> 即可。
</p>

<p><strong>取得所有模組的資料</strong></p>

<pre><code>$users = User::all();
</code></pre>

<p><strong>透過主鍵 (Primary Key) 取得單筆資料</strong></p>

<pre><code>$user = User::find(1);

var_dump($user-&gt;name);
</code></pre>

<blockquote>
  <p><strong>注意:</strong> 所有在 <a href="../../docs/queries">Query產生器</a> 的方法，在使用 Eloquent 模組時也可以使用。</p>
</blockquote>

<p><strong>透過主鍵 (Primary Key) 取得單筆資料，或丟出例外狀況</strong></p>

<p>
    假如模組沒有找到指定的資料，有時你可能想要丟出例外狀況，讓你的例外狀況可以讓 <code>App::error</code> 捕捉到，並且呈現 404 頁面給使用者。
</p>

<pre><code>$model = User::findOrFail(1);

$model = User::where('votes', '&gt;', 100)-&gt;firstOrFail();
</code></pre>

<p>
    傾聽 <code>ModelNotFoundException</code> 可以註冊一個模組錯誤處理器
</p>

<pre><code>use Illuminate\Database\Eloquent\ModelNotFoundException;

App::error(function(ModelNotFoundException $e)
{
    return Response::make('Not Found', 404);
});
</code></pre>

<p><strong>使用 Eloquent 模組進行查詢</strong></p>

<pre><code>$users = User::where('votes', '&gt;', 100)-&gt;take(10)-&gt;get();

foreach ($users as $user)
{
    var_dump($user-&gt;name);
}
</code></pre>

<p>
    當然你也可以使用查詢產生器去整合這些函式。
</p>

<p><strong>Eloquent 整合</strong></p>

<pre><code>$count = User::where('votes', '&gt;', 100)-&gt;count();
</code></pre>

<p><a name="mass-assignment"></a></p>

<h2>大量指定</h2>

<p>
    當創建一個新的模型，通過模型構造的一組屬性。然後分配這些屬性通過質量分配模型。這是很方便，但是，可以是一個嚴重的安全問題時，一味地通過用戶輸入到模型。如果是一味通過用戶輸入到模型中，用戶可以自由修改任何和所有模型的屬性。出於這個原因，所有的雄辯的模型默認情況下，防止大規模分配。

    當建立模組時，你傳遞一個陣列屬性到模組建構子，這些屬性會經由大量指定 (mass-assignment) 的方式去指定到模組中，這樣是相當方便的，但是，當綁定使用者傳入的資料到模組中，也可能是一個 <strong>嚴重</strong> 的安全性問題，假如使用者傳入的資料綁定到模組，使用者就可以任意的修改 <strong>任何 (any)</strong> 和 <strong>所有 (all)</strong> 模組中的屬性，出於這個原因，所有的 Eloquent 模組預設會避免及保護資料不會被大量指定的方式所覆寫。
</p>

<p>
    為了使用大量指定的功能，你必須在你的模組設定 <code>fillable</code> 或 <code>guarded</code> 變數資料。
</p>

<p>
    <code>fillable</code> 變數指定那些欄位可以使用被大量指定功能指定資料，可以設定類別 (class) 或 實例 (instance) 層級的變數。
</p>

<p><strong>定義可大量指定的屬性欄位到模組</strong></p>

<pre><code>class User extends Eloquent {

    protected $fillable = array('first_name', 'last_name', 'email');

}
</code></pre>

<p>
    在這個範例，只有清單中的三個變數屬性資料可以被使用大量指定方式修改
</p>

<p>
    在 <code>fillable</code> 的反義屬性就是 <code>guarded</code>，這屬性可以設定 "黑名單" 而不只是設定 "白名單" :
</p>

<p><strong>定義受保護的屬性欄位到模組</strong></p>

<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'password');

}
</code></pre>

<p>
    在上述範例 <code>id</code> 及 <code>password</code> 屬性將不會被大量指定方式修改原模組的變數資料，所有除了這兩個變數外的變數，都可以被使用大量指定方式指定去修改資料，你也可以保護 <strong>所有</strong> 的屬性都不會被大量指定的方式修改資料值:
</p>

<p><strong>封鎖所有變數不被大量指定方式修改資料內容</strong></p>

<pre><code>protected $guarded = array('*');
</code></pre>

<p><a name="insert-update-delete"></a></p>

<h2>新增、更新及刪除</h2>

<p>
    為了透過模組建立一筆新的資料到資料庫，只需要建立新的模組實例後，並且呼叫 <code>save</code> 方法即可。
</p>

<p><strong>Saving A New Model</strong></p>

<pre><code>$user = new User;

$user-&gt;name = 'John';

$user-&gt;save();
</code></pre>

<blockquote>
  <p><strong>注意:</strong> 通常你的 Eloquent 模組都會有一個自動增加的鍵值 (key)，但你如果想要指定你自己的鍵值在模組中有自動增加的屬性，只要將 <code>incrementing</code> 設定為 <code>自動增加 (incrementing)</code> 即可。</p>
</blockquote>

<p>
    你可以使用 <code>create</code> 方法在單一行去儲存資料到模組中，插入 (INSERT) 的模組實例將會被回傳，但是在使用這樣的方式去儲存資料前，你需要在模組中指定 <code>fillable</code> 或 <code>guarded</code> 屬性，這樣 Eloquent 模組會保護你的模組不被大量指定方式所攻擊。
</p>

<p><strong>設定保護 (Guarded) 屬性到模組中</strong></p>

<pre><code>class User extends Eloquent {

    protected $guarded = array('id', 'account_id');

}
</code></pre>

<p><strong>使用模組的新增 (Create) 方法</strong></p>

<pre><code>$user = User::create(array('name' =&gt; 'John'));
</code></pre>

<p>
    為了更新資料，你需要取得資料後，並改變一個你要更新的屬性欄，並使用 <code>save</code> 方法即可更新資料:
</p>

<p><strong>更新一個已取得資料的模組</strong></p>

<pre><code>$user = User::find(1);

$user-&gt;email = 'john@foo.com';

$user-&gt;save();
</code></pre>

<p>
    有時你會須希望不僅儲存模組中的資料，也希望能夠儲存所有關聯的資料，你可以使用 <code>push</code> 的方法，去達到這樣的目的:
</p>

<p><strong>儲存模組資料及關連的資料</strong></p>

<pre><code>$user-&gt;push();
</code></pre>

<p>
    你也可以對一個集合的模組資料進行更新:
</p>

<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;update(array('status' =&gt; 2));
</code></pre>

<p>
    只需要在模組實例使用 <code>delete</code> 方法，即可刪除模組的資料:
</p>

<p><strong>刪除一存在的模組資料</strong></p>

<pre><code>$user = User::find(1);

$user-&gt;delete();
</code></pre>

<p><strong>透過鍵值刪除一存在的模組資料</strong></p>

<pre><code>User::destroy(1);

User::destroy(1, 2, 3);
</code></pre>

<p>
    單然你也可以對一模組資料集合執行刪除的動作:
</p>

<pre><code>$affectedRows = User::where('votes', '&gt;', 100)-&gt;delete();
</code></pre>

<p>
    如果你只想要更新模組的時間戳記，你可以使用 <code>touch</code> 方法去進行更新:
</p>

<p><strong>僅更新模組的時間戳記</strong></p>

<pre><code>$user-&gt;touch();
</code></pre>

<p><a name="soft-deleting"></a></p>

<h2>微刪除</h2>

<p>
    When soft deleting a model, it is not actually removed from your database. Instead, a <code>deleted_at</code> timestamp is set on the record. To enable soft deletes for a model, specify the <code>softDelete</code> property on the model:
</p>

<pre><code>class User extends Eloquent {

    protected $softDelete = true;

}
</code></pre>

<p>
    To add a <code>deleted_at</code> column to your table, you may use the <code>softDeletes</code> method from a migration:
</p>

<pre><code>$table-&gt;softDeletes();
</code></pre>

<p>
    Now, when you call the <code>delete</code> method on the model, the <code>deleted_at</code> column will be set to the current timestamp. When querying a model that uses soft deletes, the "deleted" models will not be included in query results. To force soft deleted models to appear in a result set, use the <code>withTrashed</code> method on the query:
</p>

<p><strong>Forcing Soft Deleted Models Into Results</strong></p>

<pre><code>$users = User::withTrashed()-&gt;where('account_id', 1)-&gt;get();
</code></pre>

<p>If you wish to <strong>only</strong> receive soft deleted models in your results, you may use the <code>onlyTrashed</code> method:</p>

<pre><code>$users = User::onlyTrashed()-&gt;where('account_id', 1)-&gt;get();
</code></pre>

<p>To restore a soft deleted model into an active state, use the <code>restore</code> method:</p>

<pre><code>$user-&gt;restore();
</code></pre>

<p>You may also use the <code>restore</code> method on a query:</p>

<pre><code>User::withTrashed()-&gt;where('account_id', 1)-&gt;restore();
</code></pre>

<p>The <code>restore</code> method may also be used on relationships:</p>

<pre><code>$user-&gt;posts()-&gt;restore();
</code></pre>

<p>If you wish to truly remove a model from the database, you may use the <code>forceDelete</code> method:</p>

<pre><code>$user-&gt;forceDelete();
</code></pre>

<p>The <code>forceDelete</code> method also works on relationships:</p>

<pre><code>$user-&gt;posts()-&gt;forceDelete();
</code></pre>

<p>To determine if a given model instance has been soft deleted, you may use the <code>trashed</code> method:</p>

<pre><code>if ($user-&gt;trashed())
{
    //
}
</code></pre>

<p><a name="timestamps"></a></p>

<h2>時間戳記</h2>

<p>
    By default, Eloquent will maintain the <code>created_at</code> and <code>updated_at</code> columns on your database table automatically. Simply add these <code>datetime</code> columns to your table and Eloquent will take care of the rest. If you do not wish for Eloquent to maintain these columns, add the following property to your model:
</p>

<p><strong>Disabling Auto Timestamps</strong></p>

<pre><code>class User extends Eloquent {

    protected $table = 'users';

    public $timestamps = false;

}
</code></pre>

<p>
    If you wish to customize the format of your timestamps, you may override the <code>freshTimestamp</code> method in your model:
</p>

<p><strong>Providing A Custom Timestamp Format</strong></p>

<pre><code>class User extends Eloquent {

    public function freshTimestamp()
    {
        return time();
    }

}
</code></pre>

<p><a name="query-scopes"></a></p>

<h2>查詢範圍</h2>

<p>
    Scopes allow you to easily re-use query logic in your models. To define a scope, simply prefix a model method with <code>scope</code>:
</p>

<p><strong>Defining A Query Scope</strong></p>

<pre><code>class User extends Eloquent {

    public function scopePopular($query)
    {
        return $query-&gt;where('votes', '&gt;', 100);
    }

}
</code></pre>

<p><strong>Utilizing A Query Scope</strong></p>

<pre><code>$users = User::popular()-&gt;orderBy('created_at')-&gt;get();
</code></pre>

<p><a name="relationships"></a></p>

<h2>關聯</h2>

<p>
    Of course, your database tables are probably related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy. Laravel supports four types of relationships:
</p>

<ul>
<li><a href="#one-to-one">One To One</a></li>
<li><a href="#one-to-many">One To Many</a></li>
<li><a href="#many-to-many">Many To Many</a></li>
<li><a href="#polymorphic-relations">Polymorphic Relations</a></li>
</ul>

<p><a name="one-to-one"></a></p>

<h3>One To One</h3>

<p>
    A one-to-one relationship is a very basic relation. For example, a <code>User</code> model might have one <code>Phone</code>. We can define this relation in Eloquent:
</p>

<p><strong>Defining A One To One Relation</strong></p>

<pre><code>class User extends Eloquent {

    public function phone()
    {
        return $this-&gt;hasOne('Phone');
    }

}
</code></pre>

<p>
    The first argument passed to the <code>hasOne</code> method is the name of the related model. Once the relationship is defined, we may retrieve it using Eloquent's <a href="#dynamic-properties">dynamic properties</a>:
</p>

<pre><code>$phone = User::find(1)-&gt;phone;
</code></pre>

<p>The SQL performed by this statement will be as follows:</p>

<pre><code>select * from users where id = 1

select * from phones where user_id = 1
</code></pre>

<p>
    Take note that Eloquent assumes the foreign key of the relationship based on the model name. In this case, <code>Phone</code> model is assumed to use a <code>user_id</code> foreign key. If you wish to override this convention, you may pass a second argument to the <code>hasOne</code> method:
</p>

<pre><code>return $this-&gt;hasOne('Phone', 'custom_key');
</code></pre>

<p>
    To define the inverse of the relationship on the <code>Phone</code> model, we use the <code>belongsTo</code> method:
</p>

<p><strong>Defining The Inverse Of A Relation</strong></p>

<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}
</code></pre>

<p><a name="one-to-many"></a></p>

<h3>One To Many</h3>

<p>
    An example of a one-to-many relation is a blog post that "has many" comments. We can model this relation like so:
</p>

<pre><code>class Post extends Eloquent {

    public function comments()
    {
        return $this-&gt;hasMany('Comment');
    }

}
</code></pre>

<p>Now we can access the post's comments through the <a href="#dynamic-properties">dynamic property</a>:</p>

<pre><code>$comments = Post::find(1)-&gt;comments;
</code></pre>

<p>
    If you need to add further constraints to which comments are retrieved, you may call the <code>comments</code> method and continue chaining conditions:
</p>

<pre><code>$comments = Post::find(1)-&gt;comments()-&gt;where('title', '=', 'foo')-&gt;first();
</code></pre>

<p>
    Again, you may override the conventional foreign key by passing a second argument to the <code>hasMany</code> method:
</p>

<pre><code>return $this-&gt;hasMany('Comment', 'custom_key');
</code></pre>

<p>
    To define the inverse of the relationship on the <code>Comment</code> model, we use the <code>belongsTo</code> method:
</p>

<p><strong>Defining The Inverse Of A Relation</strong></p>

<pre><code>class Comment extends Eloquent {

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}
</code></pre>

<p><a name="many-to-many"></a></p>

<h3>Many To Many</h3>

<p>
    Many-to-many relations are a more complicated relationship type. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of "Admin". Three database tables are needed for this relationship: <code>users</code>, <code>roles</code>, and <code>role_user</code>. The <code>role_user</code> table is derived from the alphabetical order of the related model names, and should have <code>user_id</code> and <code>role_id</code> columns.
</p>

<p>We can define a many-to-many relation using the <code>belongsToMany</code> method:</p>

<pre><code>class User extends Eloquent {

    public function roles()
    {
        return $this-&gt;belongsToMany('Role');
    }

}
</code></pre>

<p>Now, we can retrieve the roles through the <code>User</code> model:</p>

<pre><code>$roles = User::find(1)-&gt;roles;
</code></pre>

<p>
    If you would like to use an unconventional table name for your pivot table, you may pass it as the second argument to the <code>belongsToMany</code> method:
</p>

<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles');
</code></pre>

<p>You may also override the conventional associated keys:</p>

<pre><code>return $this-&gt;belongsToMany('Role', 'user_roles', 'user_id', 'foo_id');
</code></pre>

<p>Of course, you may also define the inverse of the relationship on the <code>Role</code> model:</p>

<pre><code>class Role extends Eloquent {

    public function users()
    {
        return $this-&gt;belongsToMany('User');
    }

}
</code></pre>

<p><a name="polymorphic-relations"></a></p>

<h3>Polymorphic Relations</h3>

<p>
    Polymorphic relations allow a model to belong to more than one other model, on a single association. For example, you might have a photo model that belongs to either a staff model or an order model. We would define this relation like so:
</p>

<pre><code>class Photo extends Eloquent {

    public function imageable()
    {
        return $this-&gt;morphTo();
    }

}

class Staff extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}

class Order extends Eloquent {

    public function photos()
    {
        return $this-&gt;morphMany('Photo', 'imageable');
    }

}
</code></pre>

<p>Now, we can retrieve the photos for either a staff member or an order:</p>

<p><strong>Retrieving A Polymorphic Relation</strong></p>

<pre><code>$staff = Staff::find(1);

foreach ($staff-&gt;photos as $photo)
{
    //
}
</code></pre>

<p>
    However, the true "polymorphic" magic is when you access the staff or order from the <code>Photo</code> model:
</p>

<p><strong>Retrieving The Owner Of A Polymorphic Relation</strong></p>

<pre><code>$photo = Photo::find(1);

$imageable = $photo-&gt;imageable;
</code></pre>

<p>The <code>imageable</code> relation on the <code>Photo</code> model will return either a <code>Staff</code> or <code>Order</code> instance, depending on which type of model owns the photo.</p>

<p>To help understand how this works, let's explore the database structure for a polymorphic relation:</p>

<p><strong>Polymorphic Relation Table Structure</strong></p>

<pre><code>staff
    id - integer
    name - string

orders
    id - integer
    price - integer

photos
    id - integer
    path - string
    imageable_id - integer
    imageable_type - string
</code></pre>

<p>
    The key fields to notice here are the <code>imageable_id</code> and <code>imageable_type</code> on the <code>photos</code> table. The ID will contain the ID value of, in this example, the owning staff or order, while the type will contain the class name of the owning model. This is what allows the ORM to determine which type of owning model to return when accessing the <code>imageable</code> relation.
</p>

<p><a name="querying-relations"></a></p>

<h2>查詢關聯</h2>

<p>
    When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, you wish to pull all blog posts that have at least one comment. To do so, you may use the <code>has</code> method:
</p>

<p><strong>Checking Relations When Selecting</strong></p>

<pre><code>$posts = Post::has('comments')-&gt;get();
</code></pre>

<p>You may also specify an operator and a count:</p>

<pre><code>$posts = Post::has('comments', '&gt;=', 3)-&gt;get();
</code></pre>

<p><a name="dynamic-properties"></a></p>

<h3>Dynamic Properties</h3>

<p>
    Eloquent allows you to access your relations via dynamic properties. Eloquent will automatically load the relationship for you, and is even smart enough to know whether to call the <code>get</code> (for one-to-many relationships) or <code>first</code> (for one-to-one relationships) method.  It will then be accessible via a dynamic property by the same name as the relation. For example, with the following model <code>$phone</code>:
</p>

<pre><code>class Phone extends Eloquent {

    public function user()
    {
        return $this-&gt;belongsTo('User');
    }

}

$phone = Phone::find(1);
</code></pre>

<p>Instead of echoing the user's email like this:</p>

<pre><code>echo $phone-&gt;user()-&gt;first()-&gt;email;
</code></pre>

<p>It may be shortened to simply:</p>

<pre><code>echo $phone-&gt;user-&gt;email;
</code></pre>

<p><a name="eager-loading"></a></p>

<h2>預先加載</h2>

<p>
    Eager loading exists to alleviate the N + 1 query problem. For example, consider a <code>Book</code> model that is related to <code>Author</code>. The relationship is defined like so:
</p>

<pre><code>class Book extends Eloquent {

    public function author()
    {
        return $this-&gt;belongsTo('Author');
    }

}
</code></pre>

<p>Now, consider the following code:</p>

<pre><code>foreach (Book::all() as $book)
{
    echo $book-&gt;author-&gt;name;
}
</code></pre>

<p>
    This loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries.
</p>

<p>
    Thankfully, we can use eager loading to drastically reduce the number of queries. The relationships that should be eager loaded may be specified via the <code>with</code> method:
</p>

<pre><code>foreach (Book::with('author')-&gt;get() as $book)
{
    echo $book-&gt;author-&gt;name;
}
</code></pre>

<p>In the loop above, only two queries will be executed:</p>

<pre><code>select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
</code></pre>

<p>Wise use of eager loading can drastically increase the performance of your application.</p>

<p>Of course, you may eager load multiple relationships at one time:</p>

<pre><code>$books = Book::with('author', 'publisher')-&gt;get();
</code></pre>

<p>You may even eager load nested relationships:</p>

<pre><code>$books = Book::with('author.contacts')-&gt;get();
</code></pre>

<p>In the example above, the <code>author</code> relationship will be eager loaded, and the author's <code>contacts</code> relation will also be loaded.</p>

<h3>Eager Load Constraints</h3>

<p>
    Sometimes you may wish to eager load a relationship, but also specify a condition for the eager load. Here's an example:
</p>

<pre><code>$users = User::with(array('posts' =&gt; function($query)
{
    $query-&gt;where('title', 'like', '%first%');
}))-&gt;get();
</code></pre>

<p>
    In this example, we're eager loading the user's posts, but only if the post's title column contains the word "first".
</p>

<h3>Lazy Eager Loading</h3>

<p>
    It is also possible to eagerly load related models directly from an already existing model collection. This may be useful when dynamically deciding whether to load related models or not, or in combination with caching.
</p>

<pre><code>$books = Book::all();

$books-&gt;load('author', 'publisher');
</code></pre>

<p><a name="inserting-related-models"></a></p>

<h2>新增相關模組</h2>

<p>
    You will often need to insert new related models. For example, you may wish to insert a new comment for a post. Instead of manually setting the <code>post_id</code> foreign key on the model, you may insert the new comment from its parent <code>Post</code> model directly:
</p>

<p><strong>Attaching A Related Model</strong></p>

<pre><code>$comment = new Comment(array('message' =&gt; 'A new comment.'));

$post = Post::find(1);

$comment = $post-&gt;comments()-&gt;save($comment);
</code></pre>

<p>In this example, the <code>post_id</code> field will automatically be set on the inserted comment.</p>

<h3>Associating Models (Belongs To)</h3>

<p>
    When updating a <code>belongsTo</code> relationship, you may use the <code>associate</code> method. This method will set the foreign key on the child model:
</p>

<pre><code>$account = Account::find(10);

$user-&gt;account()-&gt;associate($account);

$user-&gt;save();
</code></pre>

<h3>Inserting Related Models (Many To Many)</h3>

<p>
    You may also insert related models when working with many-to-many relations. Let's continue using our <code>User</code> and <code>Role</code> models as examples. We can easily attach new roles to a user using the <code>attach</code> method:
</p>

<p><strong>Attaching Many To Many Models</strong></p>

<pre><code>$user = User::find(1);

$user-&gt;roles()-&gt;attach(1);
</code></pre>

<p>You may also pass an array of attributes that should be stored on the pivot table for the relation:</p>

<pre><code>$user-&gt;roles()-&gt;attach(1, array('expires' =&gt; $expires));
</code></pre>

<p>Of course, the opposite of <code>attach</code> is <code>detach</code>:</p>

<pre><code>$user-&gt;roles()-&gt;detach(1);
</code></pre>

<p>
    You may also use the <code>sync</code> method to attach related models. The <code>sync</code> method accepts an array of IDs to place on the pivot table. After this operation is complete, only the IDs in the array will be on the intermediate table for the model:
</p>

<p><strong>Using Sync To Attach Many To Many Models</strong></p>

<pre><code>$user-&gt;roles()-&gt;sync(array(1, 2, 3));
</code></pre>

<p>You may also associate other pivot table values with the given IDs:</p>

<p><strong>Adding Pivot Data When Syncing</strong></p>

<pre><code>$user-&gt;roles()-&gt;sync(array(1 =&gt; array('expires' =&gt; true)));
</code></pre>

<p>
    Sometimes you may wish to create a new related model and attach it in a single command. For this operation, you may use the <code>save</code> method:
</p>

<pre><code>$role = new Role(array('name' =&gt; 'Editor'));

User::find(1)-&gt;roles()-&gt;save($role);
</code></pre>

<p>
    In this example, the new <code>Role</code> model will be saved and attached to the user model. You may also pass an array of attributes to place on the joining table for this operation:
</p>

<pre><code>User::find(1)-&gt;roles()-&gt;save($role, array('expires' =&gt; $expires));
</code></pre>

<p><a name="touching-parent-timestamps"></a></p>

<h2>碰觸母節點時間戳記</h2>

<p>
    When a model <code>belongsTo</code> another model, such as a <code>Comment</code> which belongs to a <code>Post</code>, it is often helpful to update the parent's timestamp when the child model is updated. For example, when a <code>Comment</code> model is updated, you may want to automatically touch the <code>updated_at</code> timestamp of the owning <code>Post</code>. Eloquent makes it easy. Just add a <code>touches</code> property containing the names of the relationships to the child model:
</p>

<pre><code>class Comment extends Eloquent {

    protected $touches = array('post');

    public function post()
    {
        return $this-&gt;belongsTo('Post');
    }

}
</code></pre>

<p>
    Now, when you update a <code>Comment</code>, the owning <code>Post</code> will have its <code>updated_at</code> column updated:
</p>

<pre><code>$comment = Comment::find(1);

$comment-&gt;text = 'Edit to this comment!';

$comment-&gt;save();
</code></pre>

<p><a name="working-with-pivot-tables"></a></p>

<h2>使用數據透視表</h2>

<p>
    As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our <code>User</code> object has many <code>Role</code> objects that it is related to. After accessing this relationship, we may access the <code>pivot</code> table on the models:
</p>

<pre><code>$user = User::find(1);

foreach ($user-&gt;roles as $role)
{
    echo $role-&gt;pivot-&gt;created_at;
}
</code></pre>

<p>
    Notice that each <code>Role</code> model we retrieve is automatically assigned a <code>pivot</code> attribute. This attribute contains a model representing the intermediate table, and may be used as any other Eloquent model.
</p>

<p>
    By default, only the keys will be present on the <code>pivot</code> object. If your pivot table contains extra attributes, you must specify them when defining the relationship:
</p>

<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withPivot('foo', 'bar');
</code></pre>

<p>
    Now the <code>foo</code> and <code>bar</code> attributes will be accessible on our <code>pivot</code> object for the <code>Role</code> model.
</p>

<p>
    If you want your pivot table to have automatically maintained <code>created_at</code> and <code>updated_at</code> timestamps, use the <code>withTimestamps</code> method on the relationship definition:
</p>

<pre><code>return $this-&gt;belongsToMany('Role')-&gt;withTimestamps();
</code></pre>

<p>To delete all records on the pivot table for a model, you may use the <code>detach</code> method:</p>

<p><strong>Deleting Records On A Pivot Table</strong></p>

<pre><code>User::find(1)-&gt;roles()-&gt;detach();
</code></pre>

<p>
    Note that this operation does not delete records from the <code>roles</code> table, but only from the pivot table.
</p>

<p><a name="collections"></a></p>

<h2>聚集</h2>

<p>
    All multi-result sets returned by Eloquent either via the <code>get</code> method or a relationship return an Eloquent <code>Collection</code> object. This object implements the <code>IteratorAggregate</code> PHP interface so it can be iterated over like an array. However, this object also has a variety of other helpful methods for working with result sets.
</p>

<p>For example, we may determine if a result set contains a given primary key using the <code>contains</code> method:</p>

<p><strong>Checking If A Collection Contains A Key</strong></p>

<pre><code>$roles = User::find(1)-&gt;roles;

if ($roles-&gt;contains(2))
{
    //
}
</code></pre>

<p>Collections may also be converted to an array or JSON:</p>

<pre><code>$roles = User::find(1)-&gt;roles-&gt;toArray();

$roles = User::find(1)-&gt;roles-&gt;toJson();
</code></pre>

<p>If a collection is cast to a string, it will be returned as JSON:</p>

<pre><code>$roles = (string) User::find(1)-&gt;roles;
</code></pre>

<p>Eloquent collections also contain a few helpful methods for looping and filtering the items they contain:</p>

<p><strong>Iterating &amp; Filtering Collections</strong></p>

<pre><code>$roles = $user-&gt;roles-&gt;each(function($role)
{

});

$roles = $user-&gt;roles-&gt;filter(function($role)
{

});
</code></pre>

<p><strong>Applying A Callback To Each Collection Object</strong></p>

<pre><code>$roles = User::find(1)-&gt;roles;

$roles-&gt;each(function($role)
{
    //  
});
</code></pre>

<p><strong>Sorting A Collection By A Value</strong></p>

<pre><code>$roles = $roles-&gt;sortBy(function($role)
{
    return $role-&gt;created_at;
});
</code></pre>

<p>
    Sometimes, you may wish to return a custom Collection object with your own added methods. You may specify this on your Eloquent model by overriding the <code>newCollection</code> method:
</p>

<p><strong>Returning A Custom Collection Type</strong></p>

<pre><code>class User extends Eloquent {

    public function newCollection(array $models = array())
    {
        return new CustomCollection($models);
    }

}
</code></pre>

<p><a name="accessors-and-mutators"></a></p>

<h2>存取及修改器</h2>

<p>
    Eloquent provides a convenient way to transform your model attributes when getting or setting them. Simply define a <code>getFooAttribute</code> method on your model to declare an accessor. Keep in mind that the methods should follow camel-casing, even though your database columns are snake-case:
</p>

<p><strong>Defining An Accessor</strong></p>

<pre><code>class User extends Eloquent {

    public function getFirstNameAttribute($value)
    {
        return ucfirst($value);
    }

}
</code></pre>

<p>
    In the example above, the <code>first_name</code> column has an accessor. Note that the value of the attribute is passed to the accessor.
</p>

<p>Mutators are declared in a similar fashion:</p>

<p><strong>Defining A Mutator</strong></p>

<pre><code>class User extends Eloquent {

    public function setFirstNameAttribute($value)
    {
        $this-&gt;attributes['first_name'] = strtolower($value);
    }

}
</code></pre>

<p><a name="date-mutators"></a></p>

<h2>日期設置器</h2>

<p>
    By default, Eloquent will convert the <code>created_at</code>, <code>updated_at</code>, and <code>deleted_at</code> columns to instances of <a href="https://github.com/briannesbitt/Carbon">Carbon</a>, which provides an assortment of helpful methods, and extends the native PHP <code>DateTime</code> class.
</p>

<p>
    You may customize which fields are automatically mutated, and even completely disable this mutation, by overriding the <code>getDates</code> method of the model:
</p>

<pre><code>public function getDates()
{
    return array('created_at');
}
</code></pre>

<p>When a column is considered a date, you may set its value to a UNIX timetamp, date string (<code>Y-m-d</code>), date-time string, and of course a <code>DateTime</code> / <code>Carbon</code> instance.</p>

<p>To totally disable date mutations, simply return an empty array from the <code>getDates</code> method:</p>

<pre><code>public function getDates()
{
    return array();
}
</code></pre>

<p><a name="model-events"></a></p>

<h2>模組事件</h2>

<p>
    Eloquent models fire several events, allowing you to hook into various points in the model's lifecycle using the following methods: <code>creating</code>, <code>created</code>, <code>updating</code>, <code>updated</code>, <code>saving</code>, <code>saved</code>, <code>deleting</code>, <code>deleted</code>. If <code>false</code> is returned from the <code>creating</code>, <code>updating</code>, or <code>saving</code> events, the action will be cancelled:
</p>

<p><strong>Cancelling Save Operations Via Events</strong></p>

<pre><code>User::creating(function($user)
{
    if ( ! $user-&gt;isValid()) return false;
});
</code></pre>

<p>Eloquent models also contain a static <code>boot</code> method, which may provide a convenient place to register your event bindings.</p>

<p><strong>Setting A Model Boot Method</strong></p>

<pre><code>class User extends Eloquent {

    public static function boot()
    {
        parent::boot();

        // Setup event bindings...
    }

}
</code></pre>

<p><a name="model-observers"></a></p>

<h2>模組觀察</h2>

<p>
    To consolidate the handling of model events, you may register a model observer. An observer class may have methods that correspond to the various model events. For example, <code>creating</code>, <code>updating</code>, <code>saving</code> methods may be on an observer, in addition to any other model event name.
</p>

<p>So, for example, a model observer might look like this:</p>

<pre><code>class UserObserver {

    public function saving($model)
    {
        //
    }

    public function saved($model)
    {
        //
    }

}
</code></pre>

<p>You may register an observer instance using the <code>observe</code> method:</p>

<pre><code>User::observe(new UserObserver);
</code></pre>

<p><a name="converting-to-arrays-or-json"></a></p>

<h2>轉換成陣列/JSON</h2>

<p>
    When building JSON APIs, you may often need to convert your models and relationships to arrays or JSON. So, Eloquent includes methods for doing so. To convert a model and its loaded relationship to an array, you may use the <code>toArray</code> method:
</p>

<p><strong>Converting A Model To An Array</strong></p>

<pre><code>$user = User::with('roles')-&gt;first();

return $user-&gt;toArray();
</code></pre>

<p>Note that entire collections of models may also be converted to arrays:</p>

<pre><code>return User::all()-&gt;toArray();
</code></pre>

<p>To convert a model to JSON, you may use the <code>toJson</code> method:</p>

<p><strong>Converting A Model To JSON</strong></p>

<pre><code>return User::find(1)-&gt;toJson();
</code></pre>

<p>
    Note that when a model or collection is cast to a string, it will be converted to JSON, meaning you can return Eloquent objects directly from your application's routes!
</p>

<p><strong>Returning A Model From A Route</strong></p>

<pre><code>Route::get('users', function()
{
    return User::all();
});
</code></pre>

<p>
    Sometimes you may wish to limit the attributes that are included in your model's array or JSON form, such as passwords. To do so, add a <code>hidden</code> property definition to your model:
</p>

<p><strong>Hiding Attributes From Array Or JSON Conversion</strong></p>

<pre><code>class User extends Eloquent {

    protected $hidden = array('password');

}
</code></pre>

<p>Alternatively, you may use the <code>visible</code> property to define a white-list:</p>

<pre><code>protected $visible = array('first_name', 'last_name');
</code></pre>
    </article>
    <div class="clearfix"></div>
    </div>
</section>



<footer>
    <div class="container">
        <a href="http://laravel.com/" title="Laravel PHP Framework" class="logo" target="_blank">
            <img src="http://laravel.com/img/footer_logo.png" alt="Laravel PHP Framework">
        </a>
        <nav class="menu">
            <ul>
                <li>
                    <a href="http://laravel.com/" title="Welcome" target="_blank">Welcome</a>
                </li>
                <li>
                    <a href="http://laravel.com/docs" title="Documentation" target="_blank">Documentation</a>
                </li>
                <li class="active">
                    <a href="../../docs/introduction" title="中文文件">中文文件</a>
                </li>
                <li>
                    <a href="http://laravel.com/api" title="API" target="_blank">API</a>
                </li>
                <li>
                    <a href="https://github.com/laravel/laravel" title="Github" target="_blank">Github</a>
                </li>
                <li>
                    <a href="http://forums.laravel.io/" title="論壇" target="_blank">論壇</a>
                </li>
                <li>
                    <a href="http://twitter.com/laravelphp" title="Twitter" target="_blank">Twitter</a>
                </li>
            </ul>
        </nav>
        <p class="copyright">Copyright &copy; 2013 Taylor Otwell. 網站由 <a href="http://casserolelabs.com/" title="Casserole Labs" target="_blank">Casserole Labs</a> 及 <a href="http://daylerees.com" title="Dayle Rees">Dayle Rees</a> 設計，中文翻譯 <a href="http://blog.kejyun.com" target="_blank">KeJyun</a> 及 <a href="http://blog.liaosankai.com" target="_blank">SANKAI</a> </p>
    </div>
</footer>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://laravel.com/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="../../js/plugins.js"></script>
<script src="../../js/main.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-31063691-6', 'kejyun.github.io');
  ga('send', 'pageview');
</script>
</body>
</html>